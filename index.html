<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Team Word Counts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Chart.js + time adapter + PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    header { max-width: 960px; margin: 0 auto 16px; }
    .muted { color: #666; font-size: 0.95rem; }
    .row { max-width: 960px; margin: 0 auto; display: grid; gap: 16px; grid-template-columns: 1fr; }
    @media (min-width: 900px) { .row { grid-template-columns: 2fr 1fr; } }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; background: #fff; }
    .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
    select, button, a.pill { padding: 8px 12px; border-radius: 999px; border: 1px solid #ddd; background: #fafafa; text-decoration: none; }
    button { cursor: pointer; }
    .grid { display: grid; gap: 8px; }
    .chart-wrap { position: relative; width: 100%; height: 420px; } /* fixes ballooning */
    canvas#chart { width: 100% !important; height: 100% !important; display: block; }
    table { width: 100%; border-collapse: collapse; font-size: 0.95rem; }
    th, td { padding: 6px 8px; border-bottom: 1px solid #eee; text-align: left; }
  </style>
</head>
<body>
  <header>
    <h1>Team Word Counts</h1>
    <p class="muted">Submit your daily words via the Google Form. Select a user to view their cumulative progress, or “All users” for comparison.</p>
  </header>

  <div class="row">
    <div class="card">
      <div class="controls">
        <label for="userSelect">User:</label>
        <select id="userSelect">
          <option value="__ALL__">All users</option>
        </select>
        <button id="refreshBtn">Refresh</button>
        <button id="downloadPngBtn">Download Chart PNG</button>
        <a id="downloadCsvLink" class="pill" href="#" target="_blank" rel="noopener">Download CSV</a>
      </div>
      <div class="chart-wrap">
        <canvas id="chart"></canvas>
      </div>
    </div>

    <div class="card">
      <h3>Submit Words</h3>
      <p class="muted">Use the Google Form to add today’s words. It can take up to a minute to appear after you submit.</p>
      <p><a id="formLink" href="#" target="_blank" rel="noopener">Open submission form →</a></p>

      <h3 style="margin-top:1rem;">Recent Entries</h3>
      <div id="recentContainer" class="grid"></div>
    </div>
  </div>

  <div class="card" style="max-width: 960px; margin: 16px auto 0;">
    <h3>Raw Data (selected user)</h3>
    <div id="tableContainer"><p class="muted">Select a user to see entries.</p></div>
  </div>

<script>
  // === CONFIG ===
  const PUBLISHED_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQS4yybk3Wsrk3XhQoX-3QA80iWwPZQPjPMTZ5qDMXghIXAPBjdw8ICnCAPOhoxibN48gDDhxjCjULE/pub?gid=1623176752&single=true&output=csv"; // Sheet: File → Share → Publish to web → pick Responses tab → CSV
  const GOOGLE_FORM_URL   = "https://docs.google.com/forms/d/e/1FAIpQLScT0CMZIyr5PYM5i3ZkyPmm-sEF0JCjXTFhZwZ88LT3GjEvwg/viewform?usp=sharing&ouid=112161238198849026052";   // optional: your Google Form
  const USER_FIELD        = "User";
  const DATE_FIELD        = "Date";        // sample shows DD/MM/YYYY
  const WORDS_FIELD       = "Word Count";  // cumulative totals per your setup
  const TS_FIELD          = "Timestamp";   // optional, used for "Recent"

  document.getElementById('downloadCsvLink').href = PUBLISHED_CSV_URL;
  if (GOOGLE_FORM_URL) document.getElementById('formLink').href = GOOGLE_FORM_URL;

  let allRows = [];
  let chart = null;

  // === UTC-safe date helpers to avoid time-zone shifts ===
  function makeUTCDate(y, m, d, h = 12) {
    // Place points at 12:00 UTC to avoid DST edge cases shifting to previous day
    return new Date(Date.UTC(y, m, d, h, 0, 0));
  }

  function parseEUDateUTC(s) {
    if (!s) return null;
    const str = String(s).trim();

    // DD/MM/YYYY
    let m = str.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (m) return makeUTCDate(+m[3], +m[2]-1, +m[1]);

    // YYYY-MM-DD
    m = str.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
    if (m) return makeUTCDate(+m[1], +m[2]-1, +m[3]);

    // Fallback
    const d = new Date(str);
    return isNaN(d) ? null : makeUTCDate(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
  }

  function isoYYYYMMDD_UTC(dateObj) {
    return dateObj.toISOString().slice(0,10); // YYYY-MM-DD
  }

  function numify(x) {
    if (x == null) return NaN;
    return Number(String(x).replace(/[^\d\.\-]/g, ''));
  }

  // === Build series (detects cumulative vs daily adds automatically) ===
  function groupData(rows) {
    const valid = rows.filter(r => {
      const u = (r[USER_FIELD] || "").trim();
      const d = parseEUDateUTC(r[DATE_FIELD]);
      const w = numify(r[WORDS_FIELD]);
      return u && d && !Number.isNaN(w);
    });

    const byUser = {};
    valid.forEach(r => {
      const user = (r[USER_FIELD] || "").trim();
      const dObj = parseEUDateUTC(r[DATE_FIELD]);
      const key  = isoYYYYMMDD_UTC(dObj);
      const val  = numify(r[WORDS_FIELD]);
      byUser[user] ??= {};
      byUser[user][key] = (byUser[user][key] || 0) + val; // sum same-day entries
    });

    const series = {};
    Object.entries(byUser).forEach(([user, dateMap]) => {
      const dates = Object.keys(dateMap).sort();
      // detect if totals are cumulative (non-decreasing)
      let nonDecreasing = true;
      for (let i=1; i<dates.length; i++) {
        if (dateMap[dates[i]] < dateMap[dates[i-1]]) { nonDecreasing = false; break; }
      }
      let running = 0;
      series[user] = dates.map(d => {
        const raw = dateMap[d];
        const added = nonDecreasing ? (raw - (running || 0)) : raw;
        running = nonDecreasing ? raw : (running + raw);
        return { date: d, added: Math.max(0, added), total: running };
      });
    });

    return series;
  }

  function pickColor(i) {
    const palette = ["#2563eb","#16a34a","#f59e0b","#ef4444","#7c3aed",
                     "#0ea5e9","#f97316","#22c55e","#eab308","#a855f7"];
    return palette[i % palette.length];
  }

  // === Render: time scale, UTC dates, goal lines Oct 10 → Nov 10 ===
  function renderChart(series, selectedUser="__ALL__") {
    const ctx = document.getElementById('chart').getContext('2d');
    if (chart) { chart.destroy(); chart = null; }

    const users = Object.keys(series).sort();
    const datasets = [];
    const allX = [];

    function pointsFor(user) {
      return (series[user] || []).map(p => {
        const [Y, M, D] = p.date.split('-').map(Number);
        const x = makeUTCDate(Y, M-1, D, 12);
        allX.push(x);
        return { x, y: p.total };
      });
    }

    if (selectedUser === "__ALL__") {
      users.forEach((u, i) => {
        const pts = pointsFor(u);
        datasets.push({
          label: u,
          data: pts,
          borderColor: pickColor(i),
          backgroundColor: "transparent",
          borderWidth: 2,
          spanGaps: true,
          tension: 0.2,
          pointRadius: 2
        });
      });
    } else {
      const pts = pointsFor(selectedUser);
      datasets.push({
        label: selectedUser,
        data: pts,
        borderColor: pickColor(0),
        backgroundColor: "transparent",
        borderWidth: 3,
        tension: 0.2,
        pointRadius: 3
      });
    }

    // Goal lines (UTC daily points)
    const startUTC = makeUTCDate(2025, 9, 10, 12); // 2025-10-10
    const endUTC   = makeUTCDate(2025,10, 10, 12); // 2025-11-10
    const spanMs   = endUTC - startUTC;
    const goalTargets = [10000, 25000, 50000];
    const dashColors  = ["#9ca3af","#d1d5db","#6b7280"];

    function eachDayUTC(a, b) {
      const out = [];
      for (let t = new Date(a.getTime()); t <= b; t.setUTCDate(t.getUTCDate() + 1)) {
        t.setUTCHours(12,0,0,0);
        out.push(new Date(t.getTime()));
      }
      return out;
    }

    const goalXs = eachDayUTC(startUTC, endUTC);
    goalXs.forEach(x => allX.push(x));

    goalTargets.forEach((target, i) => {
      const data = goalXs.map(x => {
        const t = (x - startUTC) / spanMs; // 0..1
        return { x, y: Math.max(0, target * t) };
      });
      datasets.push({
        label: `Goal ${target.toLocaleString()}`,
        data,
        borderColor: dashColors[i],
        borderWidth: 1.5,
        borderDash: [6,4],
        pointRadius: 0,
        fill: false,
        tension: 0
      });
    });

    // Pin the visible x-range at least to the goal span
    const minX = new Date(Math.min(startUTC, ...(allX.length ? allX : [startUTC])));
    const maxX = new Date(Math.max(endUTC,   ...(allX.length ? allX : [endUTC])));

    chart = new Chart(ctx, {
      type: 'line',
      data: { datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        parsing: false, // using {x,y} points
        scales: {
          x: {
            type: 'time',
            time: { unit: 'day' },
            min: minX,
            max: maxX,
            ticks: { source: 'auto' }
          },
          y: { beginAtZero: true }
        },
        plugins: { legend: { display: true } },
        animation: false
      }
    });
  }

  function renderTable(series, user) {
    const container = document.getElementById('tableContainer');
    if (user === "__ALL__" || !series[user] || series[user].length === 0) {
      container.innerHTML = '<p class="muted">Select a user to see their entries.</p>';
      return;
    }
    const rows = series[user].map(p => `<tr><td>${p.date}</td><td>${p.added}</td><td>${p.total}</td></tr>`).join("");
    container.innerHTML = `
      <table>
        <thead><tr><th>Date (UTC)</th><th>Added</th><th>Cumulative</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>`;
  }

  function renderRecent(rows) {
    const container = document.getElementById('recentContainer');
    const valid = rows.filter(r =>
      (r[USER_FIELD] || "").trim() &&
      (r[DATE_FIELD] || "").trim() &&
      String(r[WORDS_FIELD] || "").trim()
    );
    const last = valid.slice(-12);
    container.innerHTML = last.map(r => {
      const u = r[USER_FIELD];
      const d = r[DATE_FIELD];
      const w = r[WORDS_FIELD];
      const ts = r[TS_FIELD] || "";
      return `<div><strong>${u}</strong> · ${w} words · <span class="muted">${d}${ts ? " · " + ts : ""}</span></div>`;
    }).join("") || '<p class="muted">No recent entries.</p>';
  }

  async function loadData() {
    return new Promise((resolve, reject) => {
      Papa.parse(PUBLISHED_CSV_URL, {
        download: true,
        header: true,
        dynamicTyping: false,
        skipEmptyLines: true,
        complete: (res) => resolve(res.data.filter(Boolean)),
        error: reject
      });
    });
  }

  async function main() {
    document.getElementById('refreshBtn').disabled = true;
    try {
      const rows = await loadData();
      allRows = rows;
      const series = groupData(rows);

      // populate user selector
      const sel = document.getElementById('userSelect');
      const current = sel.value || "__ALL__";
      sel.innerHTML = '<option value="__ALL__">All users</option>';
      Object.keys(series).sort().forEach(u => {
        const opt = document.createElement('option');
        opt.value = u; opt.textContent = u;
        sel.appendChild(opt);
      });
      sel.value = [...sel.options].some(o => o.value === current) ? current : "__ALL__";

      renderChart(series, sel.value);
      renderTable(series, sel.value);
      renderRecent(rows);

      sel.onchange = () => { renderChart(series, sel.value); renderTable(series, sel.value); };
    } catch (e) {
      console.error(e);
      alert("Failed to load data. Check your published CSV URL and column headers.");
    } finally {
      document.getElementById('refreshBtn').disabled = false;
    }
  }

  document.getElementById('refreshBtn').addEventListener('click', main);
  document.getElementById('downloadPngBtn').addEventListener('click', () => {
    if (!chart) return;
    const link = document.createElement('a');
    link.href = chart.toBase64Image('image/png', 1.0);
    link.download = 'wordcount.png';
    link.click();
  });

  // Kick off
  main();
</script>
</body>
</html>
